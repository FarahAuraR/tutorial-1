<details>
<summary>MODULE 1</summary>

## Refleksi 1
Setelah meninjau kembali kode saya setelah menambahkan fitur baru menggunakan Spring Boot, saya telah memeriksa penerapan prinsip-prinsip clean code dan secure coding practices. Prinsip-prinsip ini termasuk penggunaan meaningful names untuk variabel dan fungsi, memastikan setiap fungsi hanya melakukan satu tugas, mengurangi penggunaan comment dengan menulis kode yang jelas, dan menggunakan struktur objek yang sesuai. Selain itu, saya juga telah membuat unit test dan functional test yang relevan.

Mungkin salah satu kesalahan pada kode saya adalah error handling serta authentication dan authorization yang belum diimplementasikan. Untuk memperbaiki hal ini, perlu ditambahkan penerapan error handling yang baik dan fitur keamanan tambahan seperti otentikasi dan otorisasi.

## Refleksi 2
Setelah menyusun unit test, saya merasa lebih yakin terhadap kebenaran kode saya. Jumlah unit test yang diperlukan dalam sebuah kelas tergantung pada kompleksitas fungsionalitas yang dimiliki oleh kelas tersebut. Penting untuk memastikan bahwa setiap fungsi yang ada telah diuji secara memadai untuk memverifikasi kinerja program secara keseluruhan. Code coverage adalah sebuah metrik yang bermanfaat untuk mengevaluasi sejauh mana kode telah diuji, namun mencapai 100% code coverage tidak menjamin bahwa tidak akan ada bug dalam kode. Ada kemungkinan bahwa beberapa kasus uji belum di-cover, atau mungkin ada bug yang terjadi karena logika yang salah atau asumsi yang salah dalam kode tersebut.

Untuk membuat rangkaian functional test baru yang mirip dengan yang sudah ada, mungkin perlu dipertimbangkan potensi pengulangan atau duplikasi kode. Menggabungkan prosedur pengaturan umum menjadi metode yang dapat digunakan kembali atau kelas utilitas dapat meningkatkan kebersihan dan kualitas kode secara keseluruhan. Ini akan membantu mengurangi duplikasi kode dan meningkatkan keterbacaan dan pemeliharaan kode.
</details>

<details>
<summary>MODULE 2</summary>

## Refleksi 1
Salah satu masalah yaitu terkait visibilitas yang saya atasi dengan mengubah class dan metode pengujian JUnit5 menjadi visibilitas default daripada menggunakan modifier public. Langkah ini membantu dalam menjaga isolasi pengujiannya serta mencegah akses yang tidak diinginkan. Kedua, terkait dengan injeksi field, khususnya penggunaan @Autowired atau @Inject dalam framework Spring. Hal ini tidak disarankan karena berpotensi menciptakan objek dalam keadaan tidak valid dan mempersulit pengujian. Strategi yang digunakan untuk mengatasi ini yaitu dengan mengubah objek yang menggunakan injeksi @Autowired pada file ProductServiceImpl.java dengan membuat inisiasi class secara langsung. Terakhir, saya membersihkan import yang tidak diperlukan karena dapat meningkatkan kompleksitas kode dan memperlambat proses kompilasi. Saya juga menambahkan import secara manual yang diperlukan untuk mengurangi potensi kesalahan.

## Refleksi 2
Menurut saya, implementasi saat ini telah memenuhi definisi Continuous Integration dan Continuous Deployment (CI/CD). Dengan github workflows, proyek dapat mengotomatisasi Continuous Integration (CI) dengan menjalankan test dan melakukan scan kode menggunakan SonarCloud setiap kali melakukan push ke repositori github. Selain itu,  otomatisasi Continuous Deployment (CD) akan melakukan deployment ke platform Koyeb setiap kali ada push atau pull request ke suatu branch.

</details>

<details>
<summary>MODULE 3</summary>

<h2>1) Explain what principles you apply to your project!</h2>

Prinsip Single Responsibility (SRP) saya terapkan dengan memisahkan `CarController` dan `ProductController` menjadi file java class yang terpisah. Dengan melakukan hal ini, saya memastikan bahwa setiap class memiliki satu tanggung jawab, yaitu mengelola operasi terkait mobil atau produk. Selain itu, saya juga menghapus setter untuk UUID di constructor model Product dan memindahkan sistem pengaturan UUID ke dalam method create di `ProductRepository`. Terakhir, saya juga menghapus extends dari `ProductController` dalam class `CarController`. Saya memastikan bahwa `CarController` hanya bertanggung jawab untuk mengendalikan mobil dan tidak tercampur dengan fungsionalitas terkait produk agar sesuai dengan prinsip SRP. Selanjutnya, dengan mengubah deklarasi `private CarServiceImpl carService;` menjadi `private CarService carService;` dalam `CarController`, saya menerapkan prinsip OCP dengan menjaga kelas tersebut open for extension tetapi closed for modification dengan implementasi `CarService` yang berbeda tanpa memodifikasi kode yang sudah ada.  Selain itu, perubahan ini juga mengikuti prinsip DIP dengan menjaga kelas `CarController` terisolasi dari detail implementasi dan bergantung pada abstraksi `CarService`. Hal ini memungkinkan fleksibilitas dalam penggantian implementasi `CarService` tanpa mempengaruhi struktur kelas `CarController`, sesuai dengan prinsip DIP. Kemudian, prinsip Interface Segregation Principle (ISP). Antarmuka `ProductService` dan `CarService` dirancang untuk berkaitan secara terpisah dengan objek Product dan Car, menyediakan hanya metode yang relevan untuk setiap objek. Ini memungkinkan pengguna antarmuka untuk mengimplementasikan hanya metode yang diperlukan, sesuai dengan prinsip ISP.

<h2>2) Explain the advantages of applying SOLID principles to your project with examples.</h2>

Pertama, dengan menerapkan prinsip SRP, kelas-kelas dalam program saya menjadi lebih fokus dan terisolasi, sehingga lebih mudah untuk memahami, memelihara, dan memperbaiki kode. Kemudian, Prinsip OCP memungkinkan saya untuk memperluas fungsionalitas tanpa harus mengubah kode yang sudah ada. Misalnya, jika saya perlu menambahkan fitur baru yang berhubungan dengan mobil ke dalam `CarController`, saya dapat melakukannya dengan membuat implementasi baru dari `CarService` tanpa harus mengganti kode yang ada pada `CarController`.  Selain itu, dengan memisahkan tanggung jawab ke dalam kelas-kelas yang terpisah dan bergantung pada antarmuka, saya dapat dengan mudah menguji setiap komponen secara terpisah dengan menggunakan unit test. Selanjutnya, dengan menerapkan DIP, program saya memungkinkan untuk berkembang dan berubah seiring waktu tanpa harus mengubah struktur kelas tingkat tinggi. Hal ini memudahkan untuk menambahkan atau mengganti komponen-komponen tanpa mempengaruhi komponen lainnya, seperti penggantian implementasi `CarService` tanpa memengaruhi `CarController` akan mendukung fleksibilitas dan pemeliharaan yang lebih baik. Penerapan ISP membantu dalam mencegah kelas-kelas yang mengimplementasikan antarmuka untuk mengimplementasikan metode yang tidak relevan, mengurangi overhead dan meningkatkan kohesi dalam desain. Terakhir, dengan menerapkan prinsip-prinsip SOLID, kemungkinan duplikasi kode akan berkurang karena setiap kelas memiliki tanggung jawab yang jelas dan terbatas.

<h2>3) Explain the disadvantages of not applying SOLID principles to your project with examples.</h2>

Ketika tidak menerapkan prinsip-prinsip SOLID, terdapat berbagai masalah yang mungkin timbul. Misalnya, tanpa menerapkan prinsip SRP, sebuah kelas dapat memiliki tanggung jawab yang berlebihan, seperti `CarController` yang juga bertanggung jawab untuk operasi terkait produk, yang dapat mengakibatkan kode menjadi kompleks dan sulit dipahami. Hal ini juga dapat menyebabkan pelanggaran terhadap prinsip Open/Closed Principle (OCP), di mana setiap perubahan atau perluasan fungsionalitas harus mengharuskan modifikasi pada kode yang sudah ada, contohnya jika `CarController` harus dimodifikasi untuk menangani fitur produk baru. Selanjutnya, tanpa menerapkan prinsip LSP, subclass mungkin tidak dapat menggantikan superclass tanpa memengaruhi kebenaran program, mengakibatkan kesulitan dalam memperluas sistem dan meningkatkan kompleksitas pengembangan perangkat lunak. Selain itu, tanpa menerapkan prinsip Interface Segregation Principle (ISP), antarmuka yang terlalu besar dan kompleks dapat menyebabkan kelas-kelas mengimplementasikan metode yang tidak relevan, mengakibatkan overhead yang tidak perlu dan meningkatkan kerentanan terhadap perubahan. Contohnya jika antarmuka `ProductService` dan `CarService` dirancang secara terpadu, kelas-kelas yang mengimplementasikan antarmuka mungkin harus mengimplementasikan metode yang tidak relevan. Terakhir, tanpa prinsip DIP akan terjadi keterikatan yang kuat antara kelas-kelas tingkat tinggi dengan implementasi kelas-kelas tingkat rendah. Sebagai contoh, jika `CarController` bergantung langsung pada implementasi `CarServiceImpl`, sulit untuk menguji secara terisolasi atau melakukan perubahan tanpa mengganggu kelas lainnya.

</details>

<details>
<summary>MODULE 4</summary>

<h2> 1. Reflect based on Percival (2017) proposed self-reflective questions (in “Principles and Best Practice of Testing” submodule, chapter “Evaluating Your Testing Objectives”), whether this TDD flow is useful enough for you or not. If not, explain things that you need to do next time you make more tests. </h2>

TDD flow ini cukup membantu saya dalam menetapkan langkah-langkah pengembangan program secara lebih terstruktur. Saya merasa aplikasi saya berfungsi dengan baik dari perspektif pengguna karena telah melakukan functional test secara memadai dan menguji semua case secara menyeluruh. Test juga membuat saya lebih yakin untuk melakukan refactor code.

<h2>2. You have created unit tests in Tutorial. Now reflect whether your tests have successfully followed F.I.R.S.T. principle or not. If not, explain things that you need to do the next time you create more tests.</h2>

Test yang telah saya buat telah mematuhi sebagian besar prinsip F.I.R.S.T. dengan baik. Saya telah memisahkan antara unitTest dan functionalTest serta memastikan bahwa setiap tes memiliki fokus yang jelas. Kemudian, saya menggunakan mock objects untuk digunakan di test dan juga menggunakan setUp untuk mencegah duplikasi object. Selain itu, setiap data yang diperlukan di dalam test akan tetap sama setiap kali testing dilakukan. Selanjutnya, meskipun kode menggunakan pernyataan assert untuk memvalidasi hasil, masih ada beberapa test yang memiliki banyak pernyataan assert di dalamnya. Hal ini menunjukkan bahwa test mungkin tidak sepenuhnya memenuhi prinsip self-validating. Terakhir, test saya sudah mencakup semua happy path dan unhappy path, serta sudah mencakup semua kemungkinan error yang dapat muncul.
</details>